{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to PizzaBot case study where you'll learn to create hands on pizzabot. Are you excited because I am!! Lets go! Case Scenario There is a new pizza place in town - PIBO PIZZERIA - serving you all kinds of pizza. Loads of meat options and loads of cheese, but don\u2019t worry if you\u2019re vegan, they have vegan options too! Bacon, pepperoni, salami, onions, pineapple - you name it - they have all the toppings of your choice. With all this variety of options, the pizzeria welcomes huge traffic of customers with varying needs every hour. And with just one manager, one waiter and one chef, the pizza ordering process become tedious during peak hours. All that this pizzeria lacks, is an assistant that can take orders effortlessly and report them to the chef. And what better than creating their own AI-powered pizza ordering chat assistant? It does sound like a vast system to bring in place, but all that the pizzeria owners know is that this should be up and running very soon. So they hire you as their AI superhero, to bring their imaginations into reality. Now, it is completely up to you how you give life to PIBO - a pizza ordering chat assistant . Roadmap Agenda User Personas Requirement Analysis Methodolody Tools in hand Installation Guidelines Task description Resources reference Getting started In order to create your first pizzabot, follow installation guidelines and initialize your bot first. To do so, you can refer to Rasa . After the instllation is complete, initilize your bot where you can refer to Rasa playground Yayy!! you've successfully built your demo but now on we'll learn to customize and create out Pizzabot. Some command that comes handy rasa init - Creates a new project with example training data, actions, and config files. rasa train - Trains a model using your NLU data and stories, saves trained model in ./models. rasa shell - Starts an action server using the Rasa SDK. rasa run actions - Print help message and exit. rasa test - Tests a trained Rasa model on any files starting with test_ Project layout 1 2 3 4 5 6 7 8 9 10 11 12 actions/ action.py # Custion actions data/ # Data nlu.yml rules.yml stories.yml modes/ tests/ config.yml credentials.yml domain.yml # The domain configuration endpoints.yml For reference, you can clone and play around with this Github repo as well.","title":"Home"},{"location":"#home","text":"Welcome to PizzaBot case study where you'll learn to create hands on pizzabot. Are you excited because I am!! Lets go!","title":"Home"},{"location":"#case-scenario","text":"There is a new pizza place in town - PIBO PIZZERIA - serving you all kinds of pizza. Loads of meat options and loads of cheese, but don\u2019t worry if you\u2019re vegan, they have vegan options too! Bacon, pepperoni, salami, onions, pineapple - you name it - they have all the toppings of your choice. With all this variety of options, the pizzeria welcomes huge traffic of customers with varying needs every hour. And with just one manager, one waiter and one chef, the pizza ordering process become tedious during peak hours. All that this pizzeria lacks, is an assistant that can take orders effortlessly and report them to the chef. And what better than creating their own AI-powered pizza ordering chat assistant? It does sound like a vast system to bring in place, but all that the pizzeria owners know is that this should be up and running very soon. So they hire you as their AI superhero, to bring their imaginations into reality. Now, it is completely up to you how you give life to PIBO - a pizza ordering chat assistant .","title":"Case Scenario"},{"location":"#roadmap","text":"Agenda User Personas Requirement Analysis Methodolody Tools in hand Installation Guidelines Task description Resources reference","title":"Roadmap"},{"location":"#getting-started","text":"In order to create your first pizzabot, follow installation guidelines and initialize your bot first. To do so, you can refer to Rasa . After the instllation is complete, initilize your bot where you can refer to Rasa playground Yayy!! you've successfully built your demo but now on we'll learn to customize and create out Pizzabot.","title":"Getting started"},{"location":"#some-command-that-comes-handy","text":"rasa init - Creates a new project with example training data, actions, and config files. rasa train - Trains a model using your NLU data and stories, saves trained model in ./models. rasa shell - Starts an action server using the Rasa SDK. rasa run actions - Print help message and exit. rasa test - Tests a trained Rasa model on any files starting with test_","title":"Some command that comes handy"},{"location":"#project-layout","text":"1 2 3 4 5 6 7 8 9 10 11 12 actions/ action.py # Custion actions data/ # Data nlu.yml rules.yml stories.yml modes/ tests/ config.yml credentials.yml domain.yml # The domain configuration endpoints.yml For reference, you can clone and play around with this Github repo as well.","title":"Project layout"},{"location":"User%20Guide/Requirement%20Analysis/","text":"Agenda Before listing down the requirements, let\u2019s look into some user personas. Who are the people that will use Pibo? Indecisive people Hungry people People with food allergies Requirement Analysis Funcation requirements As a customer, I want to be able to view the pizzeria menu so that I can order the pizza of my choice. As a customer, I want to be able to enter the pizza of my choice so that I can place a basic pizza order. As a customer, I want to be able to enter pizza size, toppings and additional info if any so that I can provide customizations for my order. As a customer, I want the chat assistant to provide a description and price of the pizza I ordered so that I know my order details before confirmation. As a customer, I want the chat assistant to handle chitchats in between conversations so that I get a human-like conversation experience. As a customer, I want the chat assistant to fall back gracefully in case of out of scope conversations so that I fulfil my objective of ordering a pizza via the chat assistant. As a system admin, I should be able to add intents according to my use case so that I can adapt the chat assistant to the user conversations. As a system admin, I should be able to visualize intent and entity misclassifications during conversations so that I can improve my chat assistant based on those reports. As a system admin, I should be readily able to integrate the database of pizza items into its knowledge base so that I can keep the chat assistant updated with the most recent data. Non-functional requirements: The chat assistant should be available without failure during peak hours. Performance-wise, the chat assistant should be able to provide order confirmations without delay. The interface of the chat assistant should be easily usable by customers of varying age groups. The chat assistant should not disclose personal information to third-party apps and should be secure","title":"Requirement Analysis"},{"location":"User%20Guide/Requirement%20Analysis/#agenda","text":"Before listing down the requirements, let\u2019s look into some user personas. Who are the people that will use Pibo? Indecisive people Hungry people People with food allergies","title":"Agenda"},{"location":"User%20Guide/Requirement%20Analysis/#requirement-analysis","text":"","title":"Requirement Analysis"},{"location":"User%20Guide/Requirement%20Analysis/#funcation-requirements","text":"As a customer, I want to be able to view the pizzeria menu so that I can order the pizza of my choice. As a customer, I want to be able to enter the pizza of my choice so that I can place a basic pizza order. As a customer, I want to be able to enter pizza size, toppings and additional info if any so that I can provide customizations for my order. As a customer, I want the chat assistant to provide a description and price of the pizza I ordered so that I know my order details before confirmation. As a customer, I want the chat assistant to handle chitchats in between conversations so that I get a human-like conversation experience. As a customer, I want the chat assistant to fall back gracefully in case of out of scope conversations so that I fulfil my objective of ordering a pizza via the chat assistant. As a system admin, I should be able to add intents according to my use case so that I can adapt the chat assistant to the user conversations. As a system admin, I should be able to visualize intent and entity misclassifications during conversations so that I can improve my chat assistant based on those reports. As a system admin, I should be readily able to integrate the database of pizza items into its knowledge base so that I can keep the chat assistant updated with the most recent data.","title":"Funcation requirements"},{"location":"User%20Guide/Requirement%20Analysis/#non-functional-requirements","text":"The chat assistant should be available without failure during peak hours. Performance-wise, the chat assistant should be able to provide order confirmations without delay. The interface of the chat assistant should be easily usable by customers of varying age groups. The chat assistant should not disclose personal information to third-party apps and should be secure","title":"Non-functional requirements:"},{"location":"User%20Guide/methodology/","text":"Install Rasa and required packages Define possible intents and entities for your chat assistant Add in 10 training NLU data samples for each intent to start with Populate lookup tables for possible values of entities Create text responses for each intent to start with Design a user story to visualize a happy path in the conversation Craft rules for the chat assistant to strictly follow Define slots to fill while asking for information from the customer Validate whether all slots are populated with the required values Define responses to deal with incomplete information from the customer Deploy your chat assistant using Docker","title":"Methodology"},{"location":"User%20Guide/objective/","text":"Objective The major objective of this PizzaBot casestudy are: To get an end-to-end overview of a pizza ordering chat assistant system. To drill down the functional and non-functional requirements of the chat assistant. To train an entity extraction model using Rasa framework. To visualize the errors made by the chat assistant and analyze misclassification reports. To design test cases for the chat assistant and verify user stories flow. To deploy the chat assistant and integrate the API to a simple frontend.","title":"Objective"},{"location":"User%20Guide/objective/#objective","text":"The major objective of this PizzaBot casestudy are: To get an end-to-end overview of a pizza ordering chat assistant system. To drill down the functional and non-functional requirements of the chat assistant. To train an entity extraction model using Rasa framework. To visualize the errors made by the chat assistant and analyze misclassification reports. To design test cases for the chat assistant and verify user stories flow. To deploy the chat assistant and integrate the API to a simple frontend.","title":"Objective"},{"location":"User%20Guide/tasks/","text":"Tasks Follow the installation instructions and initialize your demo bot. Now you should have a folder PIBO with all the necessary files set up for you. For the first step, let us start with the easy part - creating training data. For this, you will work with the data folder provided to you. Note: All the training NLU data, stories, rules and lookup tables will be created under the data folder which will be the base for training your NLU model. Start by creating NLU training data. Rasa NLU takes user input in unstructured human language form and extracts structured data in form of intents and entities. Intents are labels that represent goal or meaning and entities are important keywords that your assistant should take note of. To put it simply, intents are user intentions (verbs) that you want your assistant to handle and entities are pieces of user information (nouns) that you want your assistant to detect and store. Now if you were to annotate this as Rasa NLU data, you would do it as follows in the nlu.yml file: To follow best practices, it is good to add in 10-15 examples per intent before training your NLU model. Make sure you add variety in terms of the language structure rather than the nouns because we have lookup tables to deal with diverse entity value detection. Once you\u2019re done with creating the NLU data, let us move on to lookup tables. Lookup: As we mentioned earlier, training a model that detects multiple entities of the same type can be a tedious task. But thanks to lookups, we can simply list down all possible values for an entity in a lookup table and Rasa will take care of the rest. While listing the values, we have a separate yaml file where we list all known sets of values for a given entity. As mentioned in the official documentation, lookup tables are lists of words used to generate case-insensitive regular expression patterns. Lookups aren\u2019t that complicated to get started with, know more about their correct usage here . Knowledge base: Users will query about other attributes of an item in real-life settings, often known as dynamic queries, such as the price of a pizza or the toppings available for a specific style of pizza. To respond to this kind of inquiries from users, a knowledge base (also known as a database) about restaurants is required. However, in other domains, this information is dynamic and changes on a regular basis. As a result, all of this data cannot be hard-coded. This knowledge base can be integrated into Rasa by using Knowledge base action. Knowledge base action can also be used to deal with referential resolution. Referential resolution refers to correctly parsing the pronouns (such as it, the first one and the last one) into corresponding concrete objects. For more information about knowledge base, please refer to this link . Stories and Rules Next up is stories. You can think of a story as a script detailing the back and forth conversation between user and assistant, from beginning to end. It also is the basic unit of dialogue training data. It generalizes unseen conversations paths, and you add stories on stories.yml file inside data/ folder. Since we used the rasa init command to create the assistant earlier, we should see a few examples already on stories.yml. Let\u2019s take a look at it. Here is one example with a story named happy path followed by steps that have intent and action pair. Action defines the hard coded response the bot should provide in case of a given intent prediction. I hope you\u2019re ready to add your own stories now. Let\u2019s create a story Place order 1 which lets the user order the pizza and after that confirms the order of the user too. Let me show you an example of action utter_ask_order. We define these responses on a file called domain.yml which we\u2019ll look into later on. If you\u2019re wondering what the conversation looks like for a given story, here is how it goes. Now let\u2019s talk about rules. It is a short piece of conversation that should always follow the same path. And it is great to handle specific conversations, but unlike stories, rules cannot generalize to unseen conversation paths. Like stories, you\u2019ll add your rules on rules.yml inside the data/ directory. Let\u2019s see an example. Slots: In simple words, Slots are chatbots memory that enables it to store important details and later use them in a specific context. Let us assume that we have ordered a small size pizza and, after a certain time of conversation when the user wants the bot to repeat what has been ordered, at that point bot should be able to respond with small size pizza. The slot can be set in two different ways: using NLU data and by using Custom action. Here is the basic template which should be added to the domain.yml file for using the slot. To know more about slots, refer to this link . Custom Actions Till now, we were adding our response template directly to our domain file which was the easiest way to define the message an assistant sends the user once a specific utterance is predicted. But there is another way to achieve the same result - by creating custom actions. Custom actions are response actions that include custom code. That custom code can define anything from a simple text response to a backend integration - an API call, connecting to the database, or anything else your assistant needs to do. Custom actions are defined in a file called actions.py inside the action folder. Again, the rasa init function created a sample file for us, this time including the code for a simple Hello World custom action, which we will examine to better understand custom actions. Next, we have a class of custom actions called ActionConfirmOrder. The class consists of two functions - name and run. The function name in the class must match the name of the custom action in your training stories (in stories.yml). For example, when the custom action action_confirm_order is included in a story, Rasa knows to run the code defined in the custom action class named action_confirm_order. The run function within the class contains the code to be executed, once the custom action is predicted. The run function is where you can define what the custom action actually does. Note the tracker and dispatcher elements, which are very useful and important pieces of the run function: * the tracker keeps track of what happens at each point within a dialogue - what intents were predicted, which entities where extracted, as well as other information * the dispatcher is the element that sends the response back to the user. Updating this actions file for our pizza confirmation would look like this. We created a class called ActionConfirmOrder that, when the action called action_confirm_order is predicted, the assistant retrieves the entity(which could be pizza you ordered eg. mushroom pizza) if it is present and respond with,\u201dOrder for placed for: mushroom pizza\u201d or else it responds with,\u201dSorry, I couldn't get the item you want to order.\u201d in case of none entity found. Forms: Most of the time, chatbots are used to gather data from the user and take actions based on it. So, Forms are used to collect information from the user (For example: What size would you like your pizza to be?) and, the collected information is set in a slot for later use. To use forms, we need to make sure that the Rule policy is set to config.yml file Now, we need to define the form in domain.yml file At last, we need to add a story or rule, which describes when to open or close the form. To know more about forms, refer to this link . Fallback and chitchats: Keeping the technical stuff aside, another major requirement we should be looking into while building chatbots is its versatility - its ability to gracefully fall back while the user diverts from the main topic and bring them back on track. On the other side, it should also be able to deal with a few chitchats and off-topic queries that the user might send. An example scenario would be as follows. Notice how a human and a chatbot would deal with a similar situation. But if you train your chat assistant to deal with such situations with a few chitchats and fallback, your chat assistant could operate in such a way: You might think, chitchats can be of multiple types - and the definition of chitchat can vary from person to person. So it wouldn\u2019t be logical to add a different intent for each chitchat that exists. For this, Rasa provides the concept of sub-intents that branch out from the main intent. For instance, you can have a main intent called chitchat, and you can create sub-intents that denote possible categories of chitchat like chitchat/is_bot, chitchat/where_born, etc. And for your convenience, you can even craft different responses for these sub-intents. A sample code snippet is here: And the respective responses for each sub-intent can go into a separate responses.yml file like this: Domain The domain is like the universe of your assistant which specifies all the intents, entities, slots, responses, forms and actions your bot should know about. It defines the environment in which the assistant operates including: What the user means: specifically, what intents and entities the model can understand What responses the model can provide: such as utterances or custom actions What to say next: what the model should be ready to respond with What info to remember: what information an assistant should remember and use throughout the conversation Voil\u00e0","title":"Tasks"},{"location":"User%20Guide/tasks/#tasks","text":"Follow the installation instructions and initialize your demo bot. Now you should have a folder PIBO with all the necessary files set up for you. For the first step, let us start with the easy part - creating training data. For this, you will work with the data folder provided to you. Note: All the training NLU data, stories, rules and lookup tables will be created under the data folder which will be the base for training your NLU model. Start by creating NLU training data. Rasa NLU takes user input in unstructured human language form and extracts structured data in form of intents and entities. Intents are labels that represent goal or meaning and entities are important keywords that your assistant should take note of. To put it simply, intents are user intentions (verbs) that you want your assistant to handle and entities are pieces of user information (nouns) that you want your assistant to detect and store. Now if you were to annotate this as Rasa NLU data, you would do it as follows in the nlu.yml file: To follow best practices, it is good to add in 10-15 examples per intent before training your NLU model. Make sure you add variety in terms of the language structure rather than the nouns because we have lookup tables to deal with diverse entity value detection. Once you\u2019re done with creating the NLU data, let us move on to lookup tables. Lookup: As we mentioned earlier, training a model that detects multiple entities of the same type can be a tedious task. But thanks to lookups, we can simply list down all possible values for an entity in a lookup table and Rasa will take care of the rest. While listing the values, we have a separate yaml file where we list all known sets of values for a given entity. As mentioned in the official documentation, lookup tables are lists of words used to generate case-insensitive regular expression patterns. Lookups aren\u2019t that complicated to get started with, know more about their correct usage here . Knowledge base: Users will query about other attributes of an item in real-life settings, often known as dynamic queries, such as the price of a pizza or the toppings available for a specific style of pizza. To respond to this kind of inquiries from users, a knowledge base (also known as a database) about restaurants is required. However, in other domains, this information is dynamic and changes on a regular basis. As a result, all of this data cannot be hard-coded. This knowledge base can be integrated into Rasa by using Knowledge base action. Knowledge base action can also be used to deal with referential resolution. Referential resolution refers to correctly parsing the pronouns (such as it, the first one and the last one) into corresponding concrete objects. For more information about knowledge base, please refer to this link . Stories and Rules Next up is stories. You can think of a story as a script detailing the back and forth conversation between user and assistant, from beginning to end. It also is the basic unit of dialogue training data. It generalizes unseen conversations paths, and you add stories on stories.yml file inside data/ folder. Since we used the rasa init command to create the assistant earlier, we should see a few examples already on stories.yml. Let\u2019s take a look at it. Here is one example with a story named happy path followed by steps that have intent and action pair. Action defines the hard coded response the bot should provide in case of a given intent prediction. I hope you\u2019re ready to add your own stories now. Let\u2019s create a story Place order 1 which lets the user order the pizza and after that confirms the order of the user too. Let me show you an example of action utter_ask_order. We define these responses on a file called domain.yml which we\u2019ll look into later on. If you\u2019re wondering what the conversation looks like for a given story, here is how it goes. Now let\u2019s talk about rules. It is a short piece of conversation that should always follow the same path. And it is great to handle specific conversations, but unlike stories, rules cannot generalize to unseen conversation paths. Like stories, you\u2019ll add your rules on rules.yml inside the data/ directory. Let\u2019s see an example. Slots: In simple words, Slots are chatbots memory that enables it to store important details and later use them in a specific context. Let us assume that we have ordered a small size pizza and, after a certain time of conversation when the user wants the bot to repeat what has been ordered, at that point bot should be able to respond with small size pizza. The slot can be set in two different ways: using NLU data and by using Custom action. Here is the basic template which should be added to the domain.yml file for using the slot. To know more about slots, refer to this link . Custom Actions Till now, we were adding our response template directly to our domain file which was the easiest way to define the message an assistant sends the user once a specific utterance is predicted. But there is another way to achieve the same result - by creating custom actions. Custom actions are response actions that include custom code. That custom code can define anything from a simple text response to a backend integration - an API call, connecting to the database, or anything else your assistant needs to do. Custom actions are defined in a file called actions.py inside the action folder. Again, the rasa init function created a sample file for us, this time including the code for a simple Hello World custom action, which we will examine to better understand custom actions. Next, we have a class of custom actions called ActionConfirmOrder. The class consists of two functions - name and run. The function name in the class must match the name of the custom action in your training stories (in stories.yml). For example, when the custom action action_confirm_order is included in a story, Rasa knows to run the code defined in the custom action class named action_confirm_order. The run function within the class contains the code to be executed, once the custom action is predicted. The run function is where you can define what the custom action actually does. Note the tracker and dispatcher elements, which are very useful and important pieces of the run function: * the tracker keeps track of what happens at each point within a dialogue - what intents were predicted, which entities where extracted, as well as other information * the dispatcher is the element that sends the response back to the user. Updating this actions file for our pizza confirmation would look like this. We created a class called ActionConfirmOrder that, when the action called action_confirm_order is predicted, the assistant retrieves the entity(which could be pizza you ordered eg. mushroom pizza) if it is present and respond with,\u201dOrder for placed for: mushroom pizza\u201d or else it responds with,\u201dSorry, I couldn't get the item you want to order.\u201d in case of none entity found. Forms: Most of the time, chatbots are used to gather data from the user and take actions based on it. So, Forms are used to collect information from the user (For example: What size would you like your pizza to be?) and, the collected information is set in a slot for later use. To use forms, we need to make sure that the Rule policy is set to config.yml file Now, we need to define the form in domain.yml file At last, we need to add a story or rule, which describes when to open or close the form. To know more about forms, refer to this link . Fallback and chitchats: Keeping the technical stuff aside, another major requirement we should be looking into while building chatbots is its versatility - its ability to gracefully fall back while the user diverts from the main topic and bring them back on track. On the other side, it should also be able to deal with a few chitchats and off-topic queries that the user might send. An example scenario would be as follows. Notice how a human and a chatbot would deal with a similar situation. But if you train your chat assistant to deal with such situations with a few chitchats and fallback, your chat assistant could operate in such a way: You might think, chitchats can be of multiple types - and the definition of chitchat can vary from person to person. So it wouldn\u2019t be logical to add a different intent for each chitchat that exists. For this, Rasa provides the concept of sub-intents that branch out from the main intent. For instance, you can have a main intent called chitchat, and you can create sub-intents that denote possible categories of chitchat like chitchat/is_bot, chitchat/where_born, etc. And for your convenience, you can even craft different responses for these sub-intents. A sample code snippet is here: And the respective responses for each sub-intent can go into a separate responses.yml file like this: Domain The domain is like the universe of your assistant which specifies all the intents, entities, slots, responses, forms and actions your bot should know about. It defines the environment in which the assistant operates including: What the user means: specifically, what intents and entities the model can understand What responses the model can provide: such as utterances or custom actions What to say next: what the model should be ready to respond with What info to remember: what information an assistant should remember and use throughout the conversation Voil\u00e0","title":"Tasks"}]}